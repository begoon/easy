# ===== LEXICAL =====

Identifier <- !Reserved [A-Za-z_] [A-Za-z0-9_]*
Real      <- [0-9]+ '.' ( [0-9]+ / ![0-9] ) ( [eE] [+\-]? [0-9]+ )?
Integer   <- [0-9]+
Boolean   <- 'TRUE' / 'FALSE'

String <- '"' ( '""' / '\\' . / (!'"' .) )* '"'
        / "'" ( "''" / '\\' . / (!"'" .) )* "'"

RealX      <- whole:[0-9]+ '.' frac:[0-9]+ ([eE] sign:[+\-]? exp:[0-9]+)?
IntegerX   <- digits:[0-9]+

Reserved <- ( 'PROGRAM' / 'END' / 'EXTERNAL' / 'PROCEDURE' / 'FUNCTION'
         / 'TYPE' / 'IS' / 'ARRAY' / 'OF' / 'STRUCTURE' / 'FIELD'
         / 'DECLARE' / 'NAME' / 'BEGIN' / 'FOR' / 'DO' / 'BY' / 'TO'
         / 'WHILE' / 'IF' / 'THEN' / 'ELSE' / 'FI'
         / 'CALL' / 'RETURN' / 'EXIT'
         / 'SELECT' / 'CASE' / 'OTHERWISE'
         / 'REPEAT' / 'REPENT' / 'NPUT' / 'OUTPUT'
         / 'INTEGER' / 'REAL' / 'BOOLEAN' / 'STRING'
         / 'MOD' / 'XOR' / 'NOT' ) ![A-Za-z0-9_]

# ===== TOP LEVEL =====

compilation <- program_segment+

program_segment <- main:main_program / external:external_procedure

# ===== COMMENTS =====

Comment <- BlockComment / LineComment
BlockComment <- '/*' (!'*/' .)* '*/'
LineComment  <- '//' (![\r\n] .)*

Skip <- ( [ \t\r\n] / Comment )*

# ===== PROGRAMS =====

main_program <-
    'PROGRAM' name:Identifier ':' body:segment_body
    'END' 'PROGRAM' end_name:Identifier ';'

# ===== EXTERNAL PROCEDURES =====

external_procedure <- external_subprogram / external_function

external_subprogram <-
    external_subprogram_head ':' body:segment_body
    'END' 'EXTERNAL' 'PROCEDURE' end_name:Identifier ';'

external_function <-
    external_function_head ':' body:segment_body
    'END' 'EXTERNAL' 'FUNCTION' end_name:Identifier ';'

external_subprogram_head <- 'EXTERNAL' 'PROCEDURE' name:external_procedure_name
external_function_head   <- 'EXTERNAL' 'FUNCTION'  name:external_procedure_name ret:external_type

external_procedure_name <- Identifier / Identifier params:external_parameter_list
external_parameter_list <- '(' head:external_parameter (',' tail:external_parameter)* ')'
external_parameter      <- id:Identifier t:external_type name_kw:('NAME')?

external_type <- bt:basic_type

# ===== SEGMENTS =====

segment_body <-
    type_defs:type_definition*
    var_decls:variable_declaration*
    proc_defs:procedure_definition*
    stmts:executable_statement+

# ===== TYPES =====

type_definition <- 'TYPE' name:Identifier 'IS' def:type ';'

type <- bt:basic_type / arr:arrayed_type / str:structured_type / ref:type_identifier

basic_type <- 'INTEGER' / 'REAL' / 'BOOLEAN' / 'STRING'

arrayed_type <- 'ARRAY' bounds 'OF' elem:type

bounds <- '[' lo:expression ']' / '[' lo:expression ':' hi:expression ']'

structured_type <- 'STRUCTURE' fields:field_list 'END' 'STRUCTURE'

# right-recursive to avoid repetition corner cases
field_list <- head:field (',' tail:field_list)?
field      <- 'FIELD' name:Identifier 'IS' t:type

type_identifier <- name:Identifier

# ===== DECLARATIONS =====

variable_declaration    <- 'DECLARE' names:declared_names t:type ';'
declared_names          <- declared_one_name / declared_multiple_names
declared_one_name       <- Identifier
declared_multiple_names <- '(' head:Identifier (',' tail:Identifier)* ')'

# ===== INTERNAL PROCEDURES =====

procedure_definition <- subprogram_definition / function_definition / external_subprogram_def / external_function_def

subprogram_definition <- subprogram_head ':' body:segment_body 'END' 'PROCEDURE' end_name:Identifier ';'
function_definition   <- function_head   ':' body:segment_body 'END' 'FUNCTION'  end_name:Identifier ';'

external_subprogram_def <- head:external_subprogram_head ';'
external_function_def   <- head:external_function_head ';'

subprogram_head <- 'PROCEDURE' name:procedure_name
function_head   <- 'FUNCTION'  name:procedure_name ret:type

procedure_name          <-  Identifier params:internal_parameter_list / Identifier
internal_parameter_list <- '(' head:internal_parameter (',' tail:internal_parameter)* ')'
internal_parameter      <- id:Identifier t:type name_kw:('NAME')?

# ===== EXECUTABLE STATEMENTS =====

executable_statement <-
      assignment_statement
    / call_statement
    / return_statement
    / exit_statement
    / conditional_statement
    / compound_statement
    / iteration_statement
    / selection_statement
    / repeat_statement
    / repent_statement
    / input_statement
    / output_statement
    / null_statement

# ----- ASSIGNMENTS -----

assignment_statement <- 'SET' targets:target+ expr:expression ';'
target <- var:variable ':='

# ----- PROCEDURE CALLS -----

call_statement <- 'CALL' ref:procedure_reference ';'

procedure_reference <-  id:procedure_identifier args:actual_argument_list / id:procedure_identifier
procedure_identifier <- name:Identifier
actual_argument_list <- '(' head:expression (',' tail:expression)* ')'

# ----- RETURNS -----

return_statement <- 'RETURN' ';' / 'RETURN' value:expression ';'

# ----- EXITS -----

exit_statement <- 'EXIT' ';'

# ----- CONDITIONALS -----

conditional_statement <- simple_conditional_statement / (lbl:label simple_conditional_statement)

simple_conditional_statement <-
      'IF' cond:expression 'THEN' then_body:segment_body 'FI' ';'
    / 'IF' cond:expression 'THEN' then_body:segment_body 'ELSE' else_body:segment_body 'FI' ';'

label <- name:Identifier ':'

# ----- COMPOUND -----

compound_statement <- simple_compound / (lbl:label simple_compound)
simple_compound <- 'BEGIN' body:segment_body ('END' end_name:Identifier ';' / 'END' ';')

# ----- ITERATIONS -----

# ----- ITERATIONS -----

iteration_statement <- simple_iteration_statement / lbl:label simple_iteration_statement

simple_iteration_statement <-
    'FOR'i tgt:iteration_target ctrl:control 'DO'i body:segment_body
    ('END'i 'FOR'i end_name:Identifier ';' / 'END'i 'FOR'i ';')

iteration_target <- var:variable ':='

# Allow (step/limit) optionally followed by WHILE, or a bare WHILE by itself
control <- (step_control while_control?) / while_control

# Step/limit with flexible order (must include at least one of them)
step_control <- init:initial_value ( step:step limit:limit? / limit:limit step:step? )

initial_value <- expression
step          <- 'BY'i value:expression
limit         <- 'TO'i value:expression
while_control <- 'WHILE'i cond:expression


# ----- SELECTION -----

selection_statement <- simple_selection / (lbl:label simple_selection)

simple_selection <-
    'SELECT'i sel:expression 'OF'i body:selection_body end:selection_end

selection_body <- case_list escape_case?
selection_end  <- 'END'i 'SELECT'i end_name:Identifier ';' / 'END'i 'SELECT'i ';'

case_list <- case+
case      <- 'CASE'i sel:selector ':' body:case_body

selector    <- '(' head:expression (',' tail:expression)* ')'
escape_case <- 'OTHERWISE'i ':' body:case_body
case_body   <- segment_body

# ----- REPEAT / REPENT -----

repeat_statement <- 'REPEAT' name:Identifier ';'
repent_statement <- 'REPENT' name:Identifier ';'

# ----- INPUT / OUTPUT -----

input_statement  <- 'INPUT'  list:input_list ';'
input_list       <- head:variable (',' tail:variable)*

output_statement <- 'OUTPUT' list:output_list ';'
output_list      <- head:expression (',' tail:expression)*

# ----- NULL / LABEL -----

null_statement <- ';'

# ===== EXPRESSIONS =====

expression      <- xor_expr
xor_expr        <- head:or_expr ( 'XOR' tail:or_expr )*
or_expr         <- head:and_expr ( '|'   tail:and_expr )*
and_expr        <- head:not_expr ( '&'   tail:not_expr )*

not_expr    <- 'NOT' inner:rel_expr / rel_expr
rel_expr    <- head:concat_expr ( op:relation rhs:concat_expr )*
concat_expr <- head:add_expr    ( '||' tail:add_expr )*
add_expr    <- head:mul_expr    ( op:adding_operator rhs:mul_expr )*
mul_expr    <- head:unary_expr  ( op:multiplying_operator rhs:unary_expr )*
unary_expr  <- sign:adding_operator expr:postfix_expr / postfix_expr
postfix_expr <- primary

primary <- function_reference / variable / constant / '(' inner:expression ')'

relation            <- '<=' / '>=' / '<>' / '<' / '>' / '='
adding_operator     <- '+' / '-'
multiplying_operator <- '*' / '/' / 'MOD'

# ----- VARIABLES -----

variable <- base:Identifier parts:( ('.' field:Identifier) / ('[' index:expression ']') )*

# ----- CONSTANTS -----

constant <- Real / Integer / Boolean / String

# ----- FUNCTION CALLS -----

function_reference <-
      fn:function_identifier '(' ')'
    / fn:function_identifier '(' head:expression (',' tail:expression)* ')'

function_identifier <- name:Identifier
